// prisma/schema.prisma
datasource db {
provider  = "postgresql"
url      = env("DATABASE_URL")
directUrl = env("DIRECT_URL")
}

generator client {
  provider = "prisma-client-js"
}

// Base User Model with Auth
model User {
  id            String    @id @default(cuid())
  name          String?
  email         String    @unique
  emailVerified DateTime?
  image         String?
  password      String?
  
  // Auth relations
  accounts      Account[]
  sessions      Session[]
  authenticators Authenticator[]

  // Role and type
  userType     UserType?
  
  // Profile relations
  brand         Brand?    
  influencer    Influencer?

  // Team memberships
  brandTeamMemberships    BrandTeamMember[]
  influencerTeamMemberships  InfluencerTeamMember[]

  // Chat relations
  sentMessages     Message[]  @relation("SentMessages")
  receivedMessages Message[]  @relation("ReceivedMessages")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum UserType {
  BRAND
  INFLUENCER
}

// Auth Models
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model VerificationToken {
  id         String   @id @default(cuid())
  email      String
  token      String   @unique
  expires    DateTime

  @@unique([email, token])
}

model Authenticator {
  credentialID         String  @unique
  userId               String
  providerAccountId    String
  credentialPublicKey  String
  counter              Int
  credentialDeviceType String
  credentialBackedUp   Boolean
  transports          String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, credentialID])
}

// Team Management
enum TeamRole {
  OWNER
  ADMIN
  MEMBER
}

// Brand Models
model Brand {
  id          String    @id @default(cuid())
  userId      String    @unique
  user        User      @relation(fields: [userId], references: [id])
  
  name        String
  logo        String?
  website     String?
  industry    String
  description String?

  targetDemographic    String?
  preferredCategories  String[]    // e.g., ["Fashion", "Beauty", "Tech"]
  minFollowers        Int?
  maxBudget          Decimal?
  preferredPlatforms  Platform[]
  
  // Team Management
  team        BrandTeam?

  // Relations
  campaigns   Campaign[]
  collaborations Collaboration[]

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
}

model BrandTeam {
  id          String    @id @default(cuid())
  brandId     String    @unique
  brand       Brand     @relation(fields: [brandId], references: [id])
  
  members     BrandTeamMember[]
  
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
}

model BrandTeamMember {
  id          String    @id @default(cuid())
  teamId      String
  team        BrandTeam @relation(fields: [teamId], references: [id])
  userId      String
  user        User      @relation(fields: [userId], references: [id])
  role        TeamRole  
  inviteStatus InviteStatus
  inviteToken String?   @unique

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@unique([teamId, userId])
}

// Influencer Models
model Influencer {
  id          String    @id @default(cuid())
  userId      String    @unique
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  name        String
  avatar      String?
  bio         String?
  category    String
  followers   Int
  platforms   Platform[]
  
  // Team Management
  team        InfluencerTeam?

  // Relations
  collaborations Collaboration[]

  youtubeAccount YouTubeAccount?

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
}

model InfluencerTeam {
  id            String    @id @default(cuid())
  influencerId  String    @unique
  influencer    Influencer @relation(fields: [influencerId], references: [id], onDelete : Cascade)
  
  members       InfluencerTeamMember[]
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
}

model InfluencerTeamMember {
  id            String    @id @default(cuid())
  teamId        String
  team          InfluencerTeam @relation(fields: [teamId], references: [id], onDelete : Cascade)
  userId        String?   // Make userId optional
  user          User?     @relation(fields: [userId], references: [id] , onDelete : Cascade) // Make user relation optional
  role          TeamRole
  inviteStatus  InviteStatus
  inviteToken   String?   @unique
  inviteEmail   String?   // Add this field to store email for pending invites
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@unique([teamId, inviteEmail]) // Add unique constraint for email invites
  @@unique([teamId, userId]) // Keep existing unique constraint
}

enum InviteStatus {
  PENDING
  ACCEPTED
  DECLINED
}

// Platform and Campaign Models
enum Platform {
  INSTAGRAM 
  YOUTUBE
  TIKTOK
  TWITTER
  LINKEDIN
}

model Campaign {
  id          String    @id @default(cuid())
  brandId     String
  brand       Brand     @relation(fields: [brandId], references: [id])
  createdById String    // Track which team member created the campaign
  
  title       String
  description String
  budget      Decimal
  requirements String[]
  platforms   Platform[]
  status      CampaignStatus
  startDate   DateTime
  endDate     DateTime
  
  collaborations Collaboration[]
  
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
}

enum CampaignStatus {
  DRAFT
  ACTIVE
  PAUSED
  COMPLETED
}

// Collaboration and Chat Models
model Collaboration {
  id            String    @id @default(cuid())
  campaignId    String
  campaign      Campaign  @relation(fields: [campaignId], references: [id])
  brandId       String
  brand         Brand     @relation(fields: [brandId], references: [id])
  influencerId  String
  influencer    Influencer @relation(fields: [influencerId], references: [id])
  
  status        CollaborationStatus
  terms         String
  deliverables  String[]
  compensation  Decimal
  
  chatRoom      ChatRoom?
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
}

enum CollaborationStatus {
  PENDING
  ACCEPTED
  ACTIVE
  COMPLETED
  CANCELLED
}


model ChatRoom {
  id              String    @id @default(cuid())
  collaborationId String    @unique
  collaboration   Collaboration @relation(fields: [collaborationId], references: [id])
  
  messages        Message[]
  
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
}

model Message {
  id          String    @id @default(cuid())
  content     String
  chatRoomId  String
  chatRoom    ChatRoom  @relation(fields: [chatRoomId], references: [id])
  
  senderId    String
  sender      User      @relation("SentMessages", fields: [senderId], references: [id])
  receiverId  String
  receiver    User      @relation("ReceivedMessages", fields: [receiverId], references: [id])
  
  read        Boolean   @default(false)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
}

model YouTubeAccount {
  id              String    @id @default(cuid())
  influencerId    String    @unique
  influencer      Influencer @relation(fields: [influencerId], references: [id], onDelete: Cascade)
  
  channelId       String    @unique
  accessToken     String    @db.Text
  refreshToken    String    @db.Text
  tokenExpires    DateTime
  
  channelTitle    String
  description     String?   @db.Text
  subscriberCount Int       @default(0)
  videoCount      Int       @default(0)
  viewCount       Int       @default(0)
  
  videos          YouTubeVideo[]
  analytics       YouTubeAnalytics[]

  lastUpdated     DateTime  @default(now())
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
}

model YouTubeVideo {
  id              String    @id @default(cuid())
  accountId       String
  account         YouTubeAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)
  
  videoId         String    @unique
  title           String
  description     String?   @db.Text
  thumbnailUrl    String
  publishedAt     DateTime
  
  viewCount       Int       @default(0)
  likeCount       Int       @default(0)
  commentCount    Int       @default(0)
  
  analytics       YouTubeVideoAnalytics[]

  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
}

model YouTubeAnalytics {
  id              String    @id @default(cuid())
  accountId       String
  account         YouTubeAccount @relation(fields: [accountId], references: [id])
  
  date            DateTime
  subscriberCount Int
  viewCount       Int
  videoCount      Int

  createdAt       DateTime  @default(now())
}

model YouTubeVideoAnalytics {
  id              String    @id @default(cuid())
  videoId         String
  video           YouTubeVideo @relation(fields: [videoId], references: [id], onDelete: Cascade)
  
  date            DateTime
  viewCount       Int
  likeCount       Int
  commentCount    Int

  createdAt       DateTime  @default(now())
}


//waitlist

model WaitlistEntry {
  id          String    @id @default(cuid())
  email       String    @unique
  userType    UserType  // Using existing UserType enum
  intention   String    @db.Text
  status      WaitlistStatus @default(PENDING)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
}

enum WaitlistStatus {
  PENDING
  APPROVED
  INVITED
  JOINED
}
