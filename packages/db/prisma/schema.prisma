// prisma/schema.prisma
datasource db {
provider  = "postgresql"
url      = env("DATABASE_URL")
directUrl = env("DIRECT_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String    @unique
  emailVerified DateTime?
  image         String?
  
  // Auth relations
  accounts      Account[]
  sessions      Session[]
  authenticators Authenticator[]

  // Role and type
  userType     UserType?
  activePortal ActivePortal? // Track which portal/app the user is currently using
  
  // Profile relations - Remove unique constraint to allow both
  brands        Brand[]    
  influencers   Influencer[]

  // Team memberships
  brandTeamMemberships    BrandTeamMember[]
  influencerTeamMemberships  InfluencerTeamMember[]

  // Chat relations
  sentMessages     Message[]  @relation("SentMessages")
  receivedMessages Message[]  @relation("ReceivedMessages")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum UserType {
  BRAND
  INFLUENCER
  BOTH
}

enum ActivePortal {
  BRAND
  INFLUENCER
}

// Auth Models
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime
 
  @@id([identifier, token])
}

model Authenticator {
  credentialID         String  @unique
  userId               String
  providerAccountId    String
  credentialPublicKey  String
  counter              Int
  credentialDeviceType String
  credentialBackedUp   Boolean
  transports          String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, credentialID])
}

// Team Management
enum TeamRole {
  OWNER
  ADMIN
  MEMBER
}

// Update Brand model - remove unique constraint on userId
model Brand {
  id          String    @id @default(cuid())
  userId      String
  user        User      @relation(fields: [userId], references: [id])
  
  name        String
  logo        String?
  website     String?
  industry    String
  description String?

  targetDemographic    String?
  preferredCategories  String[]
  minFollowers        Int?
  maxBudget          Decimal?
  preferredPlatforms  Platform[]
  
  team        BrandTeam?
  campaigns   Campaign[]
  collaborations Collaboration[]

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([userId]) // Add index for better query performance
}

model BrandTeam {
  id          String    @id @default(cuid())
  brandId     String    @unique
  brand       Brand     @relation(fields: [brandId], references: [id])
  
  members     BrandTeamMember[]
  
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
}

model BrandTeamMember {
  id          String    @id @default(cuid())
  teamId      String
  team        BrandTeam @relation(fields: [teamId], references: [id])
  userId      String?
  user        User?      @relation(fields: [userId], references: [id])
  role        TeamRole  
  inviteStatus InviteStatus
  inviteToken String?   @unique
  inviteEmail String?   // Add this field to store email for pending invites

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

 @@unique([teamId, inviteEmail]) // Add this unique constraint
  @@unique([teamId, userId])
}

// Update Influencer model - remove unique constraint on userId
model Influencer {
  id          String    @id @default(cuid())
  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  name        String
  avatar      String?
  bio         String?
  category    String
  followers   Int
  platforms   Platform[]
  
  team        InfluencerTeam?
  collaborations Collaboration[]
  youtubeAccount YouTubeAccount?

  instagramAccount InstagramAccount?

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([userId]) // Add index for better query performance
}

model InfluencerTeam {
  id            String    @id @default(cuid())
  influencerId  String    @unique
  influencer    Influencer @relation(fields: [influencerId], references: [id], onDelete : Cascade)
  
  members       InfluencerTeamMember[]
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
}

model InfluencerTeamMember {
  id            String    @id @default(cuid())
  teamId        String
  team          InfluencerTeam @relation(fields: [teamId], references: [id], onDelete : Cascade)
  userId        String?   // Make userId optional
  user          User?     @relation(fields: [userId], references: [id] , onDelete : Cascade) // Make user relation optional
  role          TeamRole
  inviteStatus  InviteStatus
  inviteToken   String?   @unique
  inviteEmail   String?   // Add this field to store email for pending invites
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@unique([teamId, inviteEmail]) // Add unique constraint for email invites
  @@unique([teamId, userId]) // Keep existing unique constraint
}

enum InviteStatus {
  PENDING
  ACCEPTED
  DECLINED
}

// Platform and Campaign Models
enum Platform {
  INSTAGRAM 
  YOUTUBE
  TIKTOK
  TWITTER
  LINKEDIN
}

model Campaign {
  id          String    @id @default(cuid())
  brandId     String
  brand       Brand     @relation(fields: [brandId], references: [id])
  createdById String    // Track which team member created the campaign
  
  title       String
  description String
  budget      Decimal
  requirements String[]
  platforms   Platform[]
  status      CampaignStatus
  startDate   DateTime
  endDate     DateTime
  
  collaborations Collaboration[]
  
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
}

enum CampaignStatus {
  DRAFT
  ACTIVE
  PAUSED
  COMPLETED
}

// Collaboration and Chat Models
model Collaboration {
  id            String    @id @default(cuid())
  campaignId    String
  campaign      Campaign  @relation(fields: [campaignId], references: [id])
  brandId       String
  brand         Brand     @relation(fields: [brandId], references: [id])
  influencerId  String
  influencer    Influencer @relation(fields: [influencerId], references: [id])
  
  status        CollaborationStatus
  terms         String
  deliverables  String[]
  compensation  Decimal
  
  chatRoom      ChatRoom?
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
}

enum CollaborationStatus {
  PENDING
  ACCEPTED
  ACTIVE
  COMPLETED
  CANCELLED
}


model ChatRoom {
  id              String    @id @default(cuid())
  collaborationId String    @unique
  collaboration   Collaboration @relation(fields: [collaborationId], references: [id])
  
  messages        Message[]
  
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
}

model Message {
  id          String    @id @default(cuid())
  content     String
  chatRoomId  String
  chatRoom    ChatRoom  @relation(fields: [chatRoomId], references: [id])
  
  senderId    String
  sender      User      @relation("SentMessages", fields: [senderId], references: [id])
  receiverId  String
  receiver    User      @relation("ReceivedMessages", fields: [receiverId], references: [id])
  
  read        Boolean   @default(false)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
}

model YouTubeAccount {
  id              String    @id @default(cuid())
  influencerId    String    @unique
  influencer      Influencer @relation(fields: [influencerId], references: [id], onDelete: Cascade)
  
  channelId       String    @unique
  accessToken     String    @db.Text
  refreshToken    String    @db.Text
  tokenExpires    DateTime
  
  channelTitle    String
  description     String?   @db.Text
  subscriberCount Int       @default(0)
  videoCount      Int       @default(0)
  viewCount       Int       @default(0)
  
  videos          YouTubeVideo[]
  analytics       YouTubeAnalytics[]

  lastUpdated     DateTime  @default(now())
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
}

model YouTubeVideo {
  id              String    @id @default(cuid())
  accountId       String
  account         YouTubeAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)
  
  videoId         String    @unique
  title           String
  description     String?   @db.Text
  thumbnailUrl    String
  publishedAt     DateTime
  
  viewCount       Int       @default(0)
  likeCount       Int       @default(0)
  commentCount    Int       @default(0)
  
  analytics       YouTubeVideoAnalytics[]

  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
}

model YouTubeAnalytics {
  id              String    @id @default(cuid())
  accountId       String
  account         YouTubeAccount @relation(fields: [accountId], references: [id])
  
  date            DateTime
  subscriberCount Int
  viewCount       Int
  videoCount      Int

  createdAt       DateTime  @default(now())
}

model YouTubeVideoAnalytics {
  id              String    @id @default(cuid())
  videoId         String
  video           YouTubeVideo @relation(fields: [videoId], references: [id], onDelete: Cascade)
  
  date            DateTime
  viewCount       Int
  likeCount       Int
  commentCount    Int

  createdAt       DateTime  @default(now())
}


//waitlist

model WaitlistEntry {
  id          String    @id @default(cuid())
  email       String    @unique
  userType    UserType  // Using existing UserType enum
  intention   String    @db.Text
  status      WaitlistStatus @default(PENDING)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
}

enum WaitlistStatus {
  PENDING
  APPROVED
  INVITED
  JOINED
}

//INSTAGRAM MODEL

model InstagramAccount {
  id              String    @id @default(cuid())
  influencerId    String    @unique
  influencer      Influencer @relation(fields: [influencerId], references: [id], onDelete: Cascade)
  
  username        String    @unique
  accessToken     String    @db.Text
  tokenExpires    DateTime
  
  // Profile data
  igAccountId     String    @unique
  followersCount  Int       @default(0)
  followingCount  Int       @default(0)
  mediaCount      Int       @default(0)
  
  // Relations
  posts           InstagramPost[]
  reels           InstagramReel[]
  stories         InstagramStory[]
  analytics       InstagramAnalytics[]

  lastUpdated     DateTime  @default(now())
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
}

model InstagramPost {
  id              String    @id @default(cuid())
  accountId       String
  account         InstagramAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)
  
  igMediaId       String    @unique
  mediaType       String    // IMAGE, VIDEO, CAROUSEL_ALBUM
  mediaUrl        String
  thumbnailUrl    String?
  permalink       String
  caption         String?   @db.Text
  
  // Engagement metrics
  likesCount      Int       @default(0)
  commentsCount   Int       @default(0)
  
  // Analytics relation
  analytics       InstagramPostAnalytics[]
  
  publishedAt     DateTime
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
}

model InstagramReel {
  id              String    @id @default(cuid())
  accountId       String
  account         InstagramAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)
  
  igMediaId       String    @unique
  mediaUrl        String
  thumbnailUrl    String
  permalink       String
  caption         String?   @db.Text
  
  // Engagement metrics
  playsCount      Int       @default(0)
  likesCount      Int       @default(0)
  commentsCount   Int       @default(0)
  
  // Analytics relation
  analytics       InstagramReelAnalytics[]
  
  publishedAt     DateTime
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
}

model InstagramStory {
  id              String    @id @default(cuid())
  accountId       String
  account         InstagramAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)
  
  igMediaId       String    @unique
  mediaType       String    // IMAGE or VIDEO
  mediaUrl        String
  
  impressions     Int       @default(0)
  replies         Int       @default(0)
  
  expiresAt       DateTime
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
}

model InstagramAnalytics {
  id              String    @id @default(cuid())
  accountId       String
  account         InstagramAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)
  
  date            DateTime
  followersCount  Int
  followingCount  Int
  mediaCount      Int
  impressions     Int
  reach           Int
  profileViews    Int

  createdAt       DateTime  @default(now())
}

model InstagramPostAnalytics {
  id              String    @id @default(cuid())
  postId          String
  post            InstagramPost @relation(fields: [postId], references: [id], onDelete: Cascade)
  
  date            DateTime
  impressions     Int
  reach           Int
  likesCount      Int
  commentsCount   Int
  saves           Int
  shares          Int

  createdAt       DateTime  @default(now())
}

model InstagramReelAnalytics {
  id              String    @id @default(cuid())
  reelId          String
  reel            InstagramReel @relation(fields: [reelId], references: [id], onDelete: Cascade)
  
  date            DateTime
  plays           Int
  impressions     Int
  reach           Int
  likesCount      Int
  commentsCount   Int
  saves           Int
  shares          Int

  createdAt       DateTime  @default(now())
}

//ROADMAP LANDING

enum RoadmapItemStatus {
  COMPLETED
  IN_PROGRESS
  PLANNED
}

enum RoadmapCategory {
  CORE_PLATFORM
  AI_FEATURES
  ANALYTICS
  INTEGRATION
  USER_EXPERIENCE
  MOBILE
  PERFORMANCE
}

model RoadmapItem {
  id                String            @id @default(cuid())
  feature           String
  status            RoadmapItemStatus
  description       String            @db.Text
  category          RoadmapCategory
  votes             Int               @default(0)
  implementationDate DateTime?
  
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
}